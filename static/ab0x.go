// Code generated by fileb0x at "2018-04-21 12:47:48.673522937 +0300 MSK m=+0.002705785" from config file "b0x.yaml" DO NOT EDIT.
// modification hash(0f2d7038416be5baf4e2dda5dff7f860.f7d60b70267ef579d9aad25918a6b087)

package static

import (
	"bytes"
	"compress/gzip"
	"io"
	"net/http"
	"os"
	"path"

	"context"
	"golang.org/x/net/webdav"
)

var (
	// CTX is a context for webdav vfs
	CTX = context.Background()

	// FS is a virtual memory file system
	FS = webdav.NewMemFS()

	// Handler is used to server files through a http handler
	Handler *webdav.Handler

	// HTTP is the http file system
	HTTP http.FileSystem = new(HTTPFS)
)

// HTTPFS implements http.FileSystem
type HTTPFS struct{}

// FileSwaggerJSON is "swagger.json"
var FileSwaggerJSON = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x02\xff\xec\x56\xc1\x6e\xdb\x38\x10\xbd\xeb\x2b\x06\xdc\x3d\xda\xd6\x62\x8f\xb9\x19\x08\xb0\x6b\xa0\x40\x03\x07\x01\x0a\x14\x39\xd0\xd2\x58\x66\x22\x91\xca\x0c\x19\xd7\x08\xfc\xef\x05\x25\xcb\x22\x65\xd9\x75\xd3\xa2\xbd\xd4\x27\x8b\x9a\x19\x3e\xce\x7b\x7c\xa3\xb7\x04\x40\x64\x46\xb3\xab\x90\xc5\x0d\x7c\x4e\x00\x00\x84\xac\xeb\x52\x65\xd2\x2a\xa3\xd3\x27\x36\x5a\x24\x00\x8f\x13\x1f\x5b\x93\xc9\x5d\x76\x5d\x2c\x6f\x65\x51\x20\x89\x1b\x10\xff\xce\xfe\x11\xcd\x9a\xd2\x6b\x23\x6e\xe0\xad\xcd\xcd\x91\x33\x52\xb5\xcf\xf5\x51\x77\x48\x95\x62\x56\x46\x33\x30\xd2\xab\xca\x10\xd8\x1a\x42\x06\xc7\x48\x40\xc8\xc6\x51\x86\x0c\x52\xe7\x20\xcb\xd2\x6c\x19\xac\x81\x4a\x6a\x59\x20\xc8\x2c\x43\x6e\x16\x8e\x81\xcd\xa6\x00\xc2\x2a\x5b\xe2\x70\x8b\xf9\xdd\xc2\x83\xdd\xb7\x07\x93\x76\xc3\x3d\xb2\xb4\x2d\x76\x5c\x00\x10\x05\xda\xe0\xf1\x14\xfd\x12\xad\x23\x7d\x80\xda\xa6\xe3\x28\x9a\x26\xd9\xd4\x48\x4d\xd3\x16\xb9\x4f\xfe\x0f\xed\xb2\x0b\x9b\x1f\x72\xc3\xf0\x5a\x92\xac\xd0\x22\xf5\x9d\x6f\x7f\x6f\xc1\x7f\x00\xf1\x37\xe1\xda\xd7\xfb\x2b\xed\x33\xd2\x07\x46\x5a\xdc\xfe\x8f\x32\x47\x12\x41\xfc\x7e\xf2\x8e\x42\x4b\x53\xe2\x4f\x28\x75\xef\x56\x6c\x95\x75\x16\xf3\x16\x5e\x54\xed\xf8\xff\x31\x09\x57\x0e\xbb\x88\x54\xe6\x95\xd2\x69\xd7\xe4\x90\xa5\xda\x0d\x58\x62\x57\x55\x92\x76\x1e\xc0\x9c\x59\x15\xba\xd3\x49\x89\xaf\x58\xc2\xda\x90\x57\xd2\x40\x60\x33\x78\x60\xcc\x9b\x97\x2b\x55\x96\x4a\x17\x50\x3b\xaa\x0d\x23\xcf\x2e\xb0\x78\xff\x87\xc5\x2b\xab\x69\x59\x35\xf7\x71\x65\xf2\x9d\x98\xc4\xef\x94\x3e\xf7\x86\xb3\x0d\x56\x32\xe2\xf7\x04\x5d\x8e\x6b\xa5\x95\xe7\x84\xd3\x31\x3e\x96\xf8\xe2\x90\xad\x88\x2a\xec\xaf\x11\xdf\xd1\x2b\x82\x2d\x7a\xc7\x68\xeb\x7f\xf0\xa2\x0a\xf5\x68\x77\x75\x73\x50\xb6\xa4\x74\x71\x3c\x90\x40\xed\xaa\x48\x04\x42\x1b\x8d\xa1\x58\x08\x65\x3e\x7c\xce\xb1\x44\x1b\x45\x6d\x49\xc5\x0b\x66\xab\x7b\x52\x1f\xa3\x6b\xd3\x42\xfc\xb8\x7a\xc2\xcc\x8e\x61\x34\xed\x9b\x23\xc6\x9a\xbc\xbe\xad\x8a\x6e\x98\xb7\xfc\xa1\x37\x5e\xa0\x20\x6c\x4b\x32\xa2\x0c\xa1\xf2\x61\xa1\x33\x2d\x6b\xde\xad\x0d\x55\xd2\x83\x17\xce\xa9\x7c\xbc\x62\x29\x57\x11\x07\x63\x45\x93\x21\xdb\xb1\xc1\x74\xaa\x99\x8f\x38\xcc\xf7\x76\xcb\x4b\x9d\x6b\x99\xe1\x39\x48\x92\x48\xc6\x52\x17\xca\x62\xc5\x27\x3a\xbf\xd8\xe2\x03\xad\xa3\x42\x0e\xbb\xf3\x6a\x4a\x57\xfd\x4e\x2c\xa3\x0d\xbf\x74\x53\x83\xde\x0f\x46\xee\x3d\x5a\x6f\x3b\x6d\xc2\x21\x1c\x14\x83\x04\x3a\x3c\xb4\x24\x35\x46\xce\x68\xad\x37\xf2\x68\x3e\xf7\xf4\xfd\xfa\x4b\x90\x0c\xc8\x11\x5f\xa6\x85\x99\x76\xce\x18\x9d\xad\x6f\x46\x1c\x5c\xcb\xec\x59\x16\x4d\x7c\xa1\xec\x2c\x33\xda\x4a\xa5\x91\x5c\x35\xd3\x68\xd3\x6c\x93\xd6\xfd\x07\x4f\x5a\x3f\x17\x69\x65\xf2\x0e\xc4\x3e\xf8\xf8\x09\xe6\xd2\xc1\xcf\x4e\xad\xfd\x0a\x57\x1b\x5c\xcf\xc9\x19\xde\x7c\x41\x58\xdc\x36\x1f\x47\xce\x0f\xe4\xa6\x4d\xed\x2c\xf6\x93\xbd\x4f\xec\xba\xe1\x49\x9b\x86\x15\xdb\x21\xf1\xe2\x90\x76\x22\x52\x52\x34\x26\x7f\x00\x72\xb7\xf3\xa7\xa9\xaf\x38\x5d\xdc\x0e\xf7\xde\xb4\x5b\x1c\x57\xbd\xe4\x14\xa1\xb7\x33\x4b\x0e\x4f\x40\x05\x23\x37\x80\x75\x3a\x07\xfc\x51\x43\x43\x6f\x3b\xd2\x19\xfa\xe4\x5b\xe7\x19\xe0\xf6\xbb\xbe\x0b\xb9\x17\x47\xb2\xff\x1a\x00\x00\xff\xff\xb0\xe3\xf0\xfe\x21\x0c\x00\x00")

func init() {
	if CTX.Err() != nil {
		panic(CTX.Err())
	}

	var err error

	var f webdav.File

	var rb *bytes.Reader
	var r *gzip.Reader

	rb = bytes.NewReader(FileSwaggerJSON)
	r, err = gzip.NewReader(rb)
	if err != nil {
		panic(err)
	}

	err = r.Close()
	if err != nil {
		panic(err)
	}

	f, err = FS.OpenFile(CTX, "swagger.json", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		panic(err)
	}

	_, err = io.Copy(f, r)
	if err != nil {
		panic(err)
	}

	err = f.Close()
	if err != nil {
		panic(err)
	}

	Handler = &webdav.Handler{
		FileSystem: FS,
		LockSystem: webdav.NewMemLS(),
	}

}

// Open a file
func (hfs *HTTPFS) Open(path string) (http.File, error) {

	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	return f, nil
}

// ReadFile is adapTed from ioutil
func ReadFile(path string) ([]byte, error) {
	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	buf := bytes.NewBuffer(make([]byte, 0, bytes.MinRead))

	// If the buffer overflows, we will get bytes.ErrTooLarge.
	// Return that as an error. Any other panic remains.
	defer func() {
		e := recover()
		if e == nil {
			return
		}
		if panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {
			err = panicErr
		} else {
			panic(e)
		}
	}()
	_, err = buf.ReadFrom(f)
	return buf.Bytes(), err
}

// WriteFile is adapTed from ioutil
func WriteFile(filename string, data []byte, perm os.FileMode) error {
	f, err := FS.OpenFile(CTX, filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	if err != nil {
		return err
	}
	n, err := f.Write(data)
	if err == nil && n < len(data) {
		err = io.ErrShortWrite
	}
	if err1 := f.Close(); err == nil {
		err = err1
	}
	return err
}

// WalkDirs looks for files in the given dir and returns a list of files in it
// usage for all files in the b0x: WalkDirs("", false)
func WalkDirs(name string, includeDirsInList bool, files ...string) ([]string, error) {
	f, err := FS.OpenFile(CTX, name, os.O_RDONLY, 0)
	if err != nil {
		return nil, err
	}

	fileInfos, err := f.Readdir(0)
	if err != nil {
		return nil, err
	}

	err = f.Close()
	if err != nil {
		return nil, err
	}

	for _, info := range fileInfos {
		filename := path.Join(name, info.Name())

		if includeDirsInList || !info.IsDir() {
			files = append(files, filename)
		}

		if info.IsDir() {
			files, err = WalkDirs(filename, includeDirsInList, files...)
			if err != nil {
				return nil, err
			}
		}
	}

	return files, nil
}

// Code generated by fileb0x at "2018-04-21 17:45:54.147453016 +0300 MSK m=+0.003755354" from config file "b0x.yaml" DO NOT EDIT.
// modification hash(2c032fd60595f09beaf5880b8f7c8f57.f7d60b70267ef579d9aad25918a6b087)

package static

import (
	"bytes"
	"compress/gzip"
	"io"
	"net/http"
	"os"
	"path"

	"context"
	"golang.org/x/net/webdav"
)

var (
	// CTX is a context for webdav vfs
	CTX = context.Background()

	// FS is a virtual memory file system
	FS = webdav.NewMemFS()

	// Handler is used to server files through a http handler
	Handler *webdav.Handler

	// HTTP is the http file system
	HTTP http.FileSystem = new(HTTPFS)
)

// HTTPFS implements http.FileSystem
type HTTPFS struct{}

// FileSwaggerJSON is "swagger.json"
var FileSwaggerJSON = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x02\xff\xec\x58\xc1\x6e\xe3\x36\x10\xbd\xfb\x2b\x06\x6c\x8f\xb6\x55\xf4\x98\x5b\x80\x00\x5b\x03\x45\xbb\x48\xb0\x45\x81\x22\x07\x5a\x1a\x2b\xdc\x95\x48\x2d\x87\x4c\x1a\x18\xfe\xf7\x62\x44\x4b\x22\x65\xd9\x89\xb3\x1b\xa4\x58\x24\x27\x8b\xe4\x0c\x1f\xe7\x3d\xce\x0c\xb3\x9d\x01\x88\xdc\x68\xf2\x35\x92\xb8\x80\x7f\x66\x00\x00\x42\x36\x4d\xa5\x72\xe9\x94\xd1\xd9\x67\x32\x5a\xcc\x00\x6e\xe7\xbc\xb6\xb1\xa6\xf0\xf9\xf3\xd6\xd2\x83\x2c\x4b\xb4\xe2\x02\xc4\xaf\xcb\x5f\x44\x3b\xa6\xf4\xc6\x88\x0b\xd8\x06\xdb\x02\x29\xb7\xaa\x61\x5b\x5e\xf5\x11\x6d\xad\x88\x94\xd1\x04\x84\xf6\x5e\xe5\x08\xe4\x8c\x45\x02\x4f\x68\xc1\x22\x19\x6f\x73\x24\x90\xba\x00\x59\x55\xe6\x81\xc0\x19\xa8\xa5\x96\x25\x82\xcc\x73\xa4\x76\xa0\x5f\xd8\x6e\x0a\x20\x9c\x72\x15\x8e\xb7\xb8\xfc\xb8\x62\xb0\xbb\x70\x30\xe9\xee\x68\x40\x96\x05\x67\xfd\x00\x80\x28\xd1\x45\x9f\x7c\x3e\x5f\xd7\xd2\x3e\xb2\xdb\x6b\x74\xde\xea\x3d\xcc\x60\x8a\x29\x92\xe5\x1e\x4a\x6b\x69\x1a\xb4\x6d\xc4\x56\x05\x5b\x7f\x40\x77\xdd\xad\xbb\xdc\x1b\xc7\xcb\x1b\x69\x65\x8d\x0e\xed\x10\xf6\xf0\xb7\x8d\x7e\x03\x88\x9f\x2d\x6e\xd8\xdf\x4f\xd9\x60\x91\x7d\x22\xb4\xab\xab\xdf\x50\x16\x68\x45\xb4\x7e\x37\x7f\x81\xa3\x6b\x53\xe1\x77\x70\x75\xe3\xd7\xe4\x94\xf3\x0e\x8b\x00\x2f\xf1\xd6\xff\xbe\x9d\xc5\x23\xfb\x5d\x44\x26\x8b\x5a\xe9\xac\x8b\x72\x4c\x51\xe3\x8f\x53\x74\x49\xa4\x4a\xdd\x89\xa4\xc2\x7b\xac\x60\x63\x2c\xcb\x68\xa4\xae\x25\x7c\x22\x2c\xda\xc9\xb5\xaa\x2a\xa5\x4b\x68\xbc\x6d\x0c\x9d\x66\xf1\xe6\x9d\xc5\x67\x7a\xd3\xb2\x6e\x2f\xe3\xda\x14\x8f\x62\x9e\xce\x29\x7d\x6c\x86\xf2\x3b\xac\x65\xc2\xef\x01\xba\x02\x37\x4a\x2b\xe6\x84\xb2\x29\x3e\xae\xf1\xab\x47\x72\x22\xf1\xb0\x3b\x47\x7c\x8c\x9d\x1a\x99\x23\x65\xdb\x4a\xae\xb1\xda\x4d\xa4\x8a\x53\x3a\xfc\x60\xa5\x76\xd0\xbb\x81\xa6\xcf\x48\x9c\x2f\x58\x89\x4f\x88\xec\x8f\xce\x34\x1c\xea\x5d\x62\xff\x0b\x89\x05\x32\x9e\xd6\xd7\x09\xcc\xa3\x6a\xd8\xf3\x0c\xad\xce\xc6\x58\xbb\x13\x4e\x4e\x86\x23\x72\x4d\x3b\x2b\xb3\xde\x9b\x8a\x1b\x81\x6f\x52\x76\xf0\x71\xbe\xac\xff\x6a\xed\xde\x35\xfd\x43\x6b\x3a\x90\xfc\xfa\x82\xee\xdb\xba\xe8\x64\x43\x73\x17\xce\xf5\x3b\xb7\x00\xb1\xb6\xdd\x63\xd3\x02\x20\x67\x95\x2e\x7b\x04\x02\xb5\xaf\x13\xed\x09\x6d\x34\xc6\x1a\xb5\x28\x8b\xf1\x77\x81\x15\xba\x64\xd5\x83\x55\xe9\x80\x79\xd0\x83\x96\x6e\x93\xab\x18\x20\xfe\xb9\xfe\x8c\xb9\x9b\xc2\x68\xc2\x4c\x8f\xb1\xb1\x7c\xa3\x9c\x4a\xfa\x21\xee\xce\xc7\x37\xf8\x04\xf3\x71\x58\x66\x13\xe4\x0a\x55\x8c\x1d\x1d\x09\x59\x3b\xb7\x31\xb6\x96\x0c\x5e\x78\xaf\x8a\x69\x8f\x81\xeb\xd3\x4e\x67\x63\xb6\xd3\xa4\x95\x8a\x35\xed\x07\xcf\x8d\x56\x5f\x95\x8f\x41\x92\xd6\xca\xf4\x86\x09\xe5\xb0\xa6\x83\xeb\x75\x32\xc4\x7b\x5a\x27\x85\x1c\x47\x27\xa4\xd2\x37\xc4\x32\x19\xf0\xa3\x09\x22\x0a\xfc\xe8\xda\xdf\xa0\xe3\x54\x97\x2c\x07\x45\x20\xc1\xee\x3f\x02\x43\x5c\x2a\x08\xdd\xc4\x4b\xae\xed\xc6\xb9\x8a\x0c\x24\xbe\xe9\x55\x60\x28\xfb\x84\xf5\x82\x0b\x81\xb5\x54\x69\x8a\x13\xff\x2e\x4a\xb3\xe8\x52\x20\x07\x8b\xcb\xff\x84\xf6\xfb\x63\x26\x06\x53\x01\x16\xe9\xd2\x46\xe6\x5f\x64\xd9\xae\x2e\x95\x5b\xe6\x46\x3b\xa9\x34\x5a\x5f\x2f\x35\xba\x2c\xbf\xcb\x86\x92\x4d\x59\xf3\xa5\xcc\x6a\x53\x74\xc7\x9f\xe0\xfe\xa0\xa7\xfe\x0e\xf4\x33\xc9\x84\xce\xf1\x93\x2b\x79\x4a\xbf\x25\xeb\x67\x44\x1e\x5f\x25\xf6\xd1\xff\x28\xa2\x56\x68\x5f\xcb\x0e\xbb\x89\x67\x54\xb4\x51\x6a\x9e\x1f\xe1\x8d\x1d\xc2\xea\xaa\xbd\x87\x9e\x9f\xce\x6d\x98\xc2\xab\x99\xdf\xe0\x83\x61\x17\x0d\x26\x6d\x11\x7b\x0c\x75\xfb\xab\x47\xfb\x98\x2a\x29\xe9\xcc\xbe\x01\x72\xb7\xf3\xdf\x0b\xf6\xb8\x58\x5d\x8d\xf7\xbe\x0b\x5b\xf4\xa3\x2c\x39\x65\x91\x4b\x99\xb3\x1e\x0f\x40\x45\x5d\x5e\x04\xeb\xb0\x07\x48\x92\x11\x0b\xad\x8d\x48\x57\xcc\xe7\x4f\x9d\x67\x84\x9b\x77\x7d\x11\x72\x16\xc7\x6c\xf7\x5f\x00\x00\x00\xff\xff\x0e\x9f\xb8\x7a\xc8\x13\x00\x00")

func init() {
	if CTX.Err() != nil {
		panic(CTX.Err())
	}

	var err error

	var f webdav.File

	var rb *bytes.Reader
	var r *gzip.Reader

	rb = bytes.NewReader(FileSwaggerJSON)
	r, err = gzip.NewReader(rb)
	if err != nil {
		panic(err)
	}

	err = r.Close()
	if err != nil {
		panic(err)
	}

	f, err = FS.OpenFile(CTX, "swagger.json", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		panic(err)
	}

	_, err = io.Copy(f, r)
	if err != nil {
		panic(err)
	}

	err = f.Close()
	if err != nil {
		panic(err)
	}

	Handler = &webdav.Handler{
		FileSystem: FS,
		LockSystem: webdav.NewMemLS(),
	}

}

// Open a file
func (hfs *HTTPFS) Open(path string) (http.File, error) {

	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	return f, nil
}

// ReadFile is adapTed from ioutil
func ReadFile(path string) ([]byte, error) {
	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	buf := bytes.NewBuffer(make([]byte, 0, bytes.MinRead))

	// If the buffer overflows, we will get bytes.ErrTooLarge.
	// Return that as an error. Any other panic remains.
	defer func() {
		e := recover()
		if e == nil {
			return
		}
		if panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {
			err = panicErr
		} else {
			panic(e)
		}
	}()
	_, err = buf.ReadFrom(f)
	return buf.Bytes(), err
}

// WriteFile is adapTed from ioutil
func WriteFile(filename string, data []byte, perm os.FileMode) error {
	f, err := FS.OpenFile(CTX, filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	if err != nil {
		return err
	}
	n, err := f.Write(data)
	if err == nil && n < len(data) {
		err = io.ErrShortWrite
	}
	if err1 := f.Close(); err == nil {
		err = err1
	}
	return err
}

// WalkDirs looks for files in the given dir and returns a list of files in it
// usage for all files in the b0x: WalkDirs("", false)
func WalkDirs(name string, includeDirsInList bool, files ...string) ([]string, error) {
	f, err := FS.OpenFile(CTX, name, os.O_RDONLY, 0)
	if err != nil {
		return nil, err
	}

	fileInfos, err := f.Readdir(0)
	if err != nil {
		return nil, err
	}

	err = f.Close()
	if err != nil {
		return nil, err
	}

	for _, info := range fileInfos {
		filename := path.Join(name, info.Name())

		if includeDirsInList || !info.IsDir() {
			files = append(files, filename)
		}

		if info.IsDir() {
			files, err = WalkDirs(filename, includeDirsInList, files...)
			if err != nil {
				return nil, err
			}
		}
	}

	return files, nil
}

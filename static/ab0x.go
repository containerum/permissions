// Code generated by fileb0x at "2018-04-20 13:41:21.398932073 +0300 MSK m=+0.004828065" from config file "b0x.yaml" DO NOT EDIT.
// modification hash(5bfa982960eb5f25e55913787073d480.f7d60b70267ef579d9aad25918a6b087)

package static

import (
	"bytes"
	"compress/gzip"
	"io"
	"net/http"
	"os"
	"path"

	"context"
	"golang.org/x/net/webdav"
)

var (
	// CTX is a context for webdav vfs
	CTX = context.Background()

	// FS is a virtual memory file system
	FS = webdav.NewMemFS()

	// Handler is used to server files through a http handler
	Handler *webdav.Handler

	// HTTP is the http file system
	HTTP http.FileSystem = new(HTTPFS)
)

// HTTPFS implements http.FileSystem
type HTTPFS struct{}

// FileSwaggerJSON is "swagger.json"
var FileSwaggerJSON = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x02\xff\xbc\x54\xc1\x6e\xdb\x30\x0c\xbd\xe7\x2b\x08\x6d\xc7\x66\x19\x76\xcc\xad\x40\x0e\xcb\x69\x45\x86\x01\x03\x86\x1c\x18\x99\x71\x55\xd8\x92\x4b\x4a\x2d\x82\x20\xff\x3e\x48\x4a\x1c\xd9\x49\xd1\xa2\x1d\x96\x93\xcd\x90\x8f\x8f\x8f\xcf\xdc\x4f\x00\x94\x76\x56\x42\x4b\xa2\xe6\xf0\x67\x02\x00\xa0\xb0\xeb\x1a\xa3\xd1\x1b\x67\x67\x0f\xe2\xac\x9a\x00\xac\x6f\x62\x6e\xc7\xae\x0a\xfa\x6d\xb9\xf2\x8c\x75\x4d\xac\xe6\xa0\xbe\x7d\xf9\xaa\x52\xcc\xd8\xad\x53\x73\xd8\xe7\xda\x8a\x44\xb3\xe9\x62\x6d\xcc\xba\x23\x6e\x8d\x88\x71\x56\x40\x88\x9f\x8c\x26\x10\xef\x98\x04\x82\x10\x03\x93\xb8\xc0\x9a\x04\xd0\x56\x80\x4d\xe3\x9e\x05\xbc\x83\x16\x2d\xd6\x04\xa8\x35\x49\x0a\xf4\x89\xa9\x29\x80\xf2\xc6\x37\x34\x6e\x71\x7b\xb7\x8c\x64\x0f\x79\x30\xf4\xf7\x72\x66\x36\xcb\x60\x7d\x00\x40\xd5\xe4\x8b\xd7\x4b\xf6\x2b\xf2\x81\xed\x91\x6a\x2e\xa7\xab\x6c\x52\xb1\xeb\x88\x93\x68\xcb\x2a\x16\xd7\xe4\x57\xa7\xb4\xdb\x63\x6d\x99\xde\x21\x63\x4b\x9e\xf8\xac\x7c\xfe\xed\x8b\x67\x00\xf5\x99\x69\x1b\xf1\x3e\xcd\xce\x15\xb3\x5f\x42\xbc\x5c\x7c\x27\xac\x88\x55\x91\x7f\xb8\x79\x07\xd0\xca\x35\xf4\x0f\xa0\x7e\x86\x8d\x78\xe3\x83\xa7\x2a\xd3\x1b\xa0\xf5\xcf\xeb\x49\x19\x39\xf4\xeb\xaa\x68\x6b\xac\x89\xfa\x15\x4b\xcb\xa2\xff\xd8\x3c\x90\x2e\x57\xa5\xfc\xae\x4b\xcb\x77\xf9\x9f\x13\xd5\x68\xe6\x8e\xd8\x1b\x92\xe1\x62\x2f\x76\x3f\x40\x11\xcf\xc6\xd6\x67\xba\xc5\xe8\xca\x54\xaf\x54\x95\x32\xa9\xad\xe3\x16\x23\x53\x15\x82\xa9\xae\x23\x36\xb8\xa1\xe6\xcd\x54\x86\x6a\x1d\xcd\x7f\xf2\x5f\xef\xab\x0f\x48\x63\xb1\x25\xe9\x50\xd3\x4b\x94\x90\x19\x77\xc3\x31\x8d\xa7\x76\xac\x66\x59\x51\x6e\xed\xaa\x09\x4a\x3d\x9e\x5c\x13\xda\xff\xdb\xfd\x05\x0b\x0e\x3e\xc9\xa3\x03\x2f\x5d\x7d\x45\xeb\x91\x15\xc6\x36\xe8\xe3\xa3\xfb\x12\x01\x61\xb9\x48\x17\x25\x58\x40\x9d\xdc\x0f\x5b\xc7\x80\x55\x6b\xec\xb9\x30\x2e\x29\xc1\x09\xf1\xb4\x44\x34\x09\xe8\x31\x10\xef\xd4\xc0\x22\x83\x0b\xf1\x01\xca\xa7\xce\xbf\xa7\x11\x71\xba\x5c\x8c\x7b\xdf\xe7\x16\x7d\x94\xe9\x31\x18\xa6\xf8\xd9\x78\x0e\x74\x41\xaa\xb8\x36\x05\x2d\xb2\xa1\x1d\xdc\xc1\x34\x6a\x79\x2f\xb3\x22\xc7\xf7\xf5\xcd\x6b\xf3\x8c\x78\xc7\xae\xef\x62\x1e\xcd\x31\x39\xfc\x0d\x00\x00\xff\xff\xea\x8c\x8b\x1f\x56\x07\x00\x00")

func init() {
	if CTX.Err() != nil {
		panic(CTX.Err())
	}

	var err error

	var f webdav.File

	var rb *bytes.Reader
	var r *gzip.Reader

	rb = bytes.NewReader(FileSwaggerJSON)
	r, err = gzip.NewReader(rb)
	if err != nil {
		panic(err)
	}

	err = r.Close()
	if err != nil {
		panic(err)
	}

	f, err = FS.OpenFile(CTX, "swagger.json", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		panic(err)
	}

	_, err = io.Copy(f, r)
	if err != nil {
		panic(err)
	}

	err = f.Close()
	if err != nil {
		panic(err)
	}

	Handler = &webdav.Handler{
		FileSystem: FS,
		LockSystem: webdav.NewMemLS(),
	}

}

// Open a file
func (hfs *HTTPFS) Open(path string) (http.File, error) {

	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	return f, nil
}

// ReadFile is adapTed from ioutil
func ReadFile(path string) ([]byte, error) {
	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	buf := bytes.NewBuffer(make([]byte, 0, bytes.MinRead))

	// If the buffer overflows, we will get bytes.ErrTooLarge.
	// Return that as an error. Any other panic remains.
	defer func() {
		e := recover()
		if e == nil {
			return
		}
		if panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {
			err = panicErr
		} else {
			panic(e)
		}
	}()
	_, err = buf.ReadFrom(f)
	return buf.Bytes(), err
}

// WriteFile is adapTed from ioutil
func WriteFile(filename string, data []byte, perm os.FileMode) error {
	f, err := FS.OpenFile(CTX, filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	if err != nil {
		return err
	}
	n, err := f.Write(data)
	if err == nil && n < len(data) {
		err = io.ErrShortWrite
	}
	if err1 := f.Close(); err == nil {
		err = err1
	}
	return err
}

// WalkDirs looks for files in the given dir and returns a list of files in it
// usage for all files in the b0x: WalkDirs("", false)
func WalkDirs(name string, includeDirsInList bool, files ...string) ([]string, error) {
	f, err := FS.OpenFile(CTX, name, os.O_RDONLY, 0)
	if err != nil {
		return nil, err
	}

	fileInfos, err := f.Readdir(0)
	if err != nil {
		return nil, err
	}

	err = f.Close()
	if err != nil {
		return nil, err
	}

	for _, info := range fileInfos {
		filename := path.Join(name, info.Name())

		if includeDirsInList || !info.IsDir() {
			files = append(files, filename)
		}

		if info.IsDir() {
			files, err = WalkDirs(filename, includeDirsInList, files...)
			if err != nil {
				return nil, err
			}
		}
	}

	return files, nil
}
